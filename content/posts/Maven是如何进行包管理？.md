---
title: "Maven是如何进行包管理？"
date: 2020-04-13T23:40:57+08:00
draft: false
---
我们都知道Java的包管理Maven的包管理在Java的学习过程中是非常重要的，所以这篇博客来了解下包管理的原理，以及如何解决包冲突；
## JVM工作原理
JVM的工作流程被设计的相当之简单：
1. 执行一个类的字节码文件
2. 如果在执行过程中碰到新的类，就去加载它
3. 重复执行以上两步

## 问题来了，JVM从哪里去找加载些类？
*首先要知道JVM执行是需要在类路径（Classpath）来找执行需要的类，为什么我们没有传，但是JVM可以找到这些类？*
答案：因为IDEA和Maven帮我们做了这些事；

在IDEA中随便运行一段测试代码，会发现终端第一行总会有一长串指令，将它们复制出来发现，是非常非常又臭又长的一串，这就是IDEA和Maven帮我们做的事情：

**将执行的类以及依赖的类，以 *-classpath或-cp* 格式，偷偷的帮我们传了**

![](/images/13.png)

正因为IDEA和Maven帮我们做了这些事，才让编译的过程变得如此简单，在IDEA和Maven诞生前，人们都是通过手动添加**classpath**来让JVM读懂读取到所需要的jar包，当依赖的包邮成百上千个，这个过程就会无比繁琐.


## 什么是包管理？
以上我们知道，在运行Java时需要传入依赖的类的路径，假如使用使用一些第三方类，那JVM从哪里去找这些类？

## Maven--包管理
Maven的约定帮我们定义了JVM需要的这些第三方的类该从哪里去找；
![](/images/14.png)
## Java的包
Java的类其实是由全限定类名在JVM中执行，**全限定类名**即**包名+类名**这样的组合，确定了是类的唯一标识；

那么问题来了，如果引用了不同版本的同名类，会怎么样？
**这就会出现依赖地狱（Classpath hell），也就是我们所说的依赖冲突；**

一般来说出现这样的报错就是出现了依赖冲突
* AbstractMethodError 
* NoClassDefFoundError 
* ClassNotFoundException
* LinkageError

## Java是如何处理依赖冲突
Java对于依赖冲突的两个解决原则：
1. *最近*的胜出
2. 如果路径相同，谁靠前声明谁赢


**什么是最近**：

比如*com.a.b.c-0.1* 和 *com.a.c-0.2*  这两个依赖，0.2的版本要比0.1版本的路径更短，所以Java会保留0.2来隐藏0.1的**classspath**
不管是最新或谁先声明，它留下的不一定是我们需要的那个版本，这时候就需要我们去手动解决冲突；

## 解决依赖冲突
**方案一：**可以通过**maven dependency：tree** 或 IDEA右侧GUI来查看项目依赖
解决办法：
1. 在项目依赖pom.xml中直接依赖某个版本，在pom文件中加入该版本的依赖：
   **（原因是利用Java冲突依赖原则，是该依赖离项目更近）**
2. 在项目依赖pom.xml中排除不需要依赖的版本：使用*exclusions*标签来表示
   
   ![](/images/15.png)
   


**方案二：**安装**maven helper**插件
在IDEA中安装**maven helper**插件，安装成功后重启IDEA后打开pom.xml，下方会显示
**Dependency Analyzer**
![](/static/images/16.png)
页面中会列出发生冲突的依赖， 找到不需要的版本，右键-exclusion，即可将此依赖排除，效果同上2



