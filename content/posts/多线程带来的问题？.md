---
title: "多线程带来的问题？"
date: 2020-04-26T21:50:21+08:00
draft: false
---
我们都知道多线程下回产生很多问题，那会带来什么问题呢？
## 多线程会带来哪些问题？
1. 原子性的问题
2. 可见性的问题
3. 有序性问题

## 原子性
> 所谓原子性，即一个操作中假如有多个步骤，这些步骤要么一起成功，要么一起失败，即，要么完整的执行，要么完全不执行，这种特性就称为原子性；
```
int i = 1 ; //原子性操作
i = i + 1 ; //非原子性操作
/**
* i = i =1 
* 其中包含了三个操作：
* （1）读取 i 的值
* （2）对 i 加 1 
* （3） 重新赋值给 i
*/ 
```
> 非原子性的操作在多线程可能会出现的问题：比如i = 0 ，线程1读取到i的值，对进行加 1 操作但还没有赋值给 i ，CPU给线程1的时间到了，让线程1等等，这时候线程2执行 i = i + 1 操作的三个步骤，执行完后 i已经1，这时候CPU告诉线程1继续执行，线程1将计算完成后的i的进行赋值，虽然进行了两次 i = i + 1 的操作，但 i 还是等于 1；

## 可见性
> 即多个线程对一个共享变量修改，结果可立即被其他线程发现
```
boolean flag = true;
while (flag) {
    // do something...
}
/**
* 对于这段代码，线程 A 在执行while循环。此时，线程 B 将flag的值修改为false，线程 A 能够马上退出循环操作，就说明变量flag具有可见性。
*/
```

> 静态变量/类变量是被所有线程共享的，即共享变量
```
public class ThreadDemo {

    private static boolean flag = true;
    
    public static void main(String[] args) throws InterruptedException {
        //线程A 
        //当 flag == false 跳出循环，线程执行结束
        new Thread(() -> {
            while (flag) {
                //do something...
            }
        }).start(); 

        //防止线程B先启动
        Thread.sleep(10);

        //线程B
        //在线程A启动后，修改flag的值为false
        new Thread(() -> flag = false).start();
    }
}
```
> 此时线程线程 A 不会结束运行，因为线程 A 拿到的flag = true，执行自己的循环任务，等待线程 B 拿到flag并修改的操作，对于线程 A 是不可见的。

## 有序性
> Java的编译器会对指令执行的顺序进行优化，来提高性能，但不会改变程序整体的运行结果。
```
(1)int a = 1;
(2)int b = 2;
(3)int c = a + b ;
(4)int d = 4; 
```
> 比如上述代码，（3）依赖（1）（2），Java虚拟机在执行的时候改变，不会把（1）（2）任意一个放到（3）之后，（4）跟其他命令都没有关系。最后不管顺序如何，（1）（2）一定在（3）之前，（4）可以放在任意位置执行。此时顺序看起来不太重要，但是在多线程情况下就会产生问题。
```
//有两个线程 A B
boolean flag = false;
//线程A
new Thread(() -> {
  create(object);//创建一个新的对象
  flag = true;
}).start();
//线程B
new Thread(() -> {
  while (true) {
    if (flag) {
      Object obj = getObject(); 
      //如果对象创建成功，就获取对象进行后续操作
    }
  }
}).start();
```
> 以上是伪代码，想表达的意思是，线程 A 进行创建对象操作，然后将flag标记为 true ， 线程 B 根据flag来判断 A 是否创建完毕来获取对象进行后续操作；
> 如果线程 A 中的顺序进行了变化，先修改了flag的值，但还没有创建好对象，此时线程B就开始执行，线程 B 就会获取不到任何对象。

## 解决办法
> Java提供了关键字synchronized来解决，对指令所在的代码块或者方法加锁，也可以共享变量使用volatile修饰以及JDK并发包中同步控制工具类和并发容器等各种工具。